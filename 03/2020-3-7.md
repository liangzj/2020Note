# 散列表
## 概念
1. 用数组支持按照下标随机访问数据的特性，数组的一种扩展实现，有数组演化而来。
2. 通过散列函数把元素的键值映射为下标，然后将数据存储再数组中对应下标的位置。
3. 查询元素时，用同样散列函数，将键值转化数组下标，从对应数组下标的位置取数据。
## 散列函数
### 概念要点
+ 根据key计算得到对应散列值的函数。
+ 三要点：
    - 散列函数计算得到的散列值是一个非负整数
    - 如果key1=key2,那hash(key1)==hash(key2)
    - 如果key1!=key2,那hash(key1)!=hash(key2)
## 散列冲突
不同key通过散列计算出来的值一样，就是散列冲突。
### 开发寻址法（open addressing）
+ 思想： 出现散列冲突时，我们就重新探测一个空闲位置。
+ 应用： 
    - 适合数据量较小、装载因子小的时候。
    - java中ThreadLocalMap使用该方法解决冲突。
+ 线性探测（Linear Probing）:
    - 插入数据：如果摸个数据经过散列函数散列之后，存储位置已经被占用，从当前位置开始，依次往后查找，直到找到空闲位置为止。
    - 查找数据：通过散列求出散列值，比对数组下标为散列值和要查找元素，相等，则说明就是要查找元素；否则就顺序往后依次查找。如果遍历到数组中空间位置，还没找到，则说明查找元素并没有在散列中。
    - 删除数据：特殊标记为deleted，当线性探测查找的时候，遇到标记为deleted的空间，并不是停下来继续往下探测。规避上面查找流程，应新删除位置为空，认定为不存在。
+ 二次探测（Quadratic probing）:
    - 与线性探测类似，但探测步长变成原来二次方，而非逐步。即hash(key)+0,hash(key)+1<sup>2</sup>,hash(key)+2<sup>2</sup>,hash(key)+3<sup>2</sup>...
+ 双重散列
    - 使用一组散列函数，直到找到空闲存储位置。 
### 链表法（chaining）
+ 应用
    - 适合存储大对象、大数据量的散列表
    - 更加灵活，支持更多的优化策略，比如用红黑树代替链表
+ 在散列表中，每个“桶”或“槽”会对应一个链表，所有散列值相同的元素，多放到相同槽位对应的链表中。

## 如何设计散列函数？
+ 散列函数的设计不能太复杂。
+ 散列函数生成的值要尽可能随机并且均匀分布。
## 装载因子
### 定义
+ 散列表装载因子 = 填入表中的元素个数 / 散列表的长度
+ 装载因子越大，说明空闲位置越小，冲突越多，散列表性能会下降。
### 过大时处理策略
+ 当装载因子过大时，可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到新散列表中。
+ 针对散列表的扩容，数据搬移操作比数组要复杂很多，需要通过散列函数重新计算每个数据的存储位置。
### 如何规避低效的扩容？
在某些特殊情况下，装载因子达到阈值进行全量扩容时，此时插入数据就会严重受影响，这时可通过以下处理规避‘一次性’扩容的不稳定性：
+ 扩容穿插在插入操作过程中，分批完成。
+ 达到触发阈值后，只申请新空间，不搬移老数据。
+ 有新数据插入是，直接插入新表，并且充老的散列表拿出部分数据放到新散列表，每次插入循环这个操作，直到老数据全部搬移完成。
+ 查询时，先从新散列表查找，没找到，再去查询老散列表。

## 工业级散列表举例分析（Java的HashMap）
+ 初始大小：默认初始16，如果事先可评估，可通过修改初始默认，规避动态扩容次数，提供性能。
+ 装载因子和动态扩容
    - 最大装载因子默认0.75
    - 大于0.75后，扩容为原来的两倍。
+ 散列冲突解决方法
    - 链表法来解决冲突，依然存储拉链过长问题。
    - JDK1.8之后，进一步优化，链表长度太长（默认超过8）时，链表会转换为红黑树；链表长度少于8时，又转化为链表。
+ 散列函数：java使用hashcode来做散列
    ```java 
    int hash(Object key) {
        int h = key.hashCode()；
        return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
    }
    ```
## 工业级散列表
### 特性要点
+ 支持快速查询、插入、删除操作。
+ 内存占用合理，不能浪费过多的内存空间。
+ 性能稳定，极端情况下，散列表的性能不会退化到无法接受的情况。
### 设计思路
+ 设计一个合适的散列函数；
+ 定义装载因子阈值，并且设计动态扩容策略；
+ 选择合适的散列冲突解决方法。
