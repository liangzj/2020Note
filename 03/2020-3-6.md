# 跳表
## 概念：
+ 链表上加多级索引的结构
+ 支持类‘二分’查找算法的顺序链表
+ Redis的有序集合（Sorted Set）该结构实现
## 复杂度分析
+ 时间复杂度： O(logn)
    - 假设索引有h级，最高级索引2个结点，即n/(2<sup>h</sup>)=2，可求出 h = log<sub>2</sub>n
    - 每层遍历m个结点，有logn层索引，时间复杂度O(mlogn)
+ 空间复杂度： O(n)
    - 假设原始链表大小为n，每2个结点抽1个，每层索引的结点：n/2+n/4+n/8+...+n/2<sup>k</sup>+...+8+4+2
    - 推导： n/2+n/4+n/8+...+n/2<sup>k</sup>+...+8+4+2=n-2 >> 总共需要n-2个索引结点，空间复杂度O(n-2)
## 高效的动态插入和删除
+ 复杂度分析：需要先查询，再插删，查询O(logn),删插O(1),所以时间复杂度是O(logn)
## 索引的动态更新
+ 再不停插入数据时，如果索引不及时更新会概率出现某2个索引结点直接数据非常多，导致跳表退化成单链表。因此需要某种方式手段维护索引与原始表大小间的平衡。
+ 随机函数插入索引：插入数据时，选择同时将这个数据插入到部分索引层中，一般是通过随机函数生成一个k值，然后我们就将所有插入到第一级到第k级索引中。
## 为什么Redis用跳表来实现有序集合，而不是红黑树？
+ Redis的有序集合支持的功能
    - 插入一个数据
    - 删除一个数据
    - 查找一个数据
    - 按区间查找数据
    - 迭代输出有序序列
+ 功能性能上，除按区间查找效率没跳表高，其它的一样复杂度。
+ 代码上，跳表实现更简单，可读。
+ 跳表可通过改变索引构建策略，有效平衡执行效率和内存消耗。

