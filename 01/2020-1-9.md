# Spring的Cache抽象
## 1. 概述
  Spring 3.0之后，Spring Framework提供了显示添加缓存到Spring Application的支持，和事务支持一样，缓存抽象用最少的代码嵌入方式实现各种缓存方案的一致实现。  
  Spring4.1 开始，随着 [JSR-107注解](https://docs.spring.io/spring/docs/5.0.13.RELEASE/spring-fsramework-reference/integration.html#cache-jsr-107) 和越来越多的自定义选项，缓存抽象更进一步得到显著改进。
## 2.理解缓存抽象
>缓存与缓冲（Cache vs Buffer)
术语中"buffer"与"cache"经常被交替使用，但请注意两者表示的意识是不同的。buffer通常用来表示快慢实体间的中间临时存储。由于一端不得不等待另一端导致慢的影响性能，而buffer通过影响一次余东整个数据块而不是一小块一小块移动从而减缓了这个影响。数据只从buffer写入和读取一次。此外，缓冲器对读取他的对象是可见的。 
另外一方面，根据定义，cache是隐藏的，而且双方都不知道缓存发生。他同样优化了性能，但是是通过快速多次读同样的数据来实现。  
>更多关于`buffer&cache`说明，请查阅维基百科的 [The_difference_between_buffer_and_cache](https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache)

 在其核心，抽象将缓存用于Java方法，从而基于缓存中的可用信息减少方法的执行次数。也就是说，每次目标方法被执行，抽象都将执行缓存行为，来检查该方法是否有被给定的一样参数执行过。如果有，则直接返回缓存结果而不再去执行实际方法；如果没有，则执行方法，并建结果缓存后返回，下次执行一样的方法是，可以直接返回改缓存结果。这种方式，对于高消耗（不管CPU或IO方面）的方法对一组给定参数只需执行一次，执行结果可复用，而不必再次重复运行该方法。缓存的逻辑是透明的并不会对调用方有任何影响。

 > 显然，这个方式只适用于那些给定特定的输入（或者参数）不管执行多少次返回输出（结果）是一致的方法。

其它缓存的操作也是有该抽象提供，比如更新缓存内容或者删除一列数据中的一项，这些对于应用运行过程中可能改变的数据来说是非常有用。

和Spring Framework的其它服务一样，缓存服务也是一个抽象（不是一个缓存实现）且需要使用实际存储去存储缓存数据-也就是说，抽象使开发者可以不必去编写缓存逻辑但也不提供实际存储。抽象通过org.springframework.cache.Cache和org.springframework.cache.CacheManager 实现。

这有些开箱即用的实现方案：JDK基于缓存的java.util.concurrent.ConcurrentMap/Ehchace2.x/Gemfire cache/Caffeine 以及符合JSP-107规范的缓存（eg.Ehcache3.x）.可通过查看 [Plugging-in different back-end caches](https://docs.spring.io/spring/docs/5.0.13.RELEASE/spring-framework-reference/integration.html#cache-plug) 获取更多关于其他缓存仓库/服务如何集成（插入）的更多信息。

> 缓存抽象对于多线程与多进程环境并无特殊处理，所以这些特性多是有缓存实现去处理。

如果你有个多进程环境（比如：应用部署在不通的服务节点上），你将需要去配置相应的缓存服务。根据你的用例场景，多个节点上建相同数据副本可能就满足，但如果应用运行中数据需要变更，则可能需要启动其它的传播机制。

缓存的特定功能项与编程实现的典型`get-if-not-found-then-proceed-and-put-eventually`代码块是一致的：没有应用锁，几个线程可能尝试并发加载同一个项。同样的适用于`eviction`:如果几个线程尝试去同时更新和删除数据，你可能使用陈旧的数据。有些缓存服务该领域上提供了高级功能，更多细节可以去查看你正在使用缓存的相应文档。

使用缓存抽象，开发者需要关注两个方面：
+ **caching declaration**: 标识需要缓存的方法及其相应需要的策略
+ **cache configuration**: 配置存储和读取数据的缓存

## 2.3 基于声明注解的缓存
为了缓存声明，抽象提供了一组Java注解
+ `@Cacheable` 开启缓存填充
+ `@CacheEvict` 触发缓存清楚
+ `@CachePut` 不干扰方法执行时更新缓存
+ `@Caching` 对于要用于该方法的多个缓存重新分组
+ `@CacheConfig` 类级别上共享一些与缓存相关的公共设置

让我们更进一步了解以下各个注释：  
### 2.3.1 @Cacheable 注解
顾名思义，`@Cacheable` 用于声明该方法可缓存-也就是，该方法会将结果存储进缓存，以此类推，随后的调用（具有相同的参数）时，缓存中的值直接返回不再去执行该方法。最简单的形式，就是注解声明需要与带注解的方法相关联的缓存的名称。
```java
@Cacheable("books")
public Book findBook(ISDN isbn){...}
```
上面的片段中，`findBook`方法关联了名称是`books`的缓存。每次该方法被调用时，都会检查缓存，是否该方法已经执行过不需要再次重复。大部分情况下，只声明一个缓存，但注解允许指定多个名称，以便使用多个缓存。在这个种情况下，执行方法前将检查每个缓存-如果至少命中一个缓存，那个关联值将直接返回：
> 即使缓存方法并没有实际执行，所有其他不包含该值的其它缓存也将同时被更新（上面的指定多个缓存值情况，不通缓存间默认会再被调用到时被同步）
```java
@Cacheable({"books","isbns"})
public Book findBook(ISDN isbn){...}
```
#### 默认key生成器
因为缓存本质上是一个key-value存储仓库，每次缓存方法调用是需要转换为适合访问缓存的key值。开箱即用的情况下，缓存抽象使用了基于以下算法的KeyGenerator(key生成器)。

+ 没有参数值，直接返回`SimpleKey.EMPTY`
+ 如果只有一个参数，返回该参数
+ 如果超过一个参数，返回一个包含所有参数的`SimpleKey`

这种方法适合于大多数场景，只要参数有自然值且实现了`hashCode()`与`equals`方法。如果不是则需要去改变相应策略。

要提供不同的默认key生成器，需要去实现一个`org.springframework.cache.interceptor.KeyGenerator`接口。

> 随着Spring4.0的发布，默认可以生成策略发生了改变，早期版本Spring使用的生成策略，在多个key参数情况下，只考虑了参数的`hashCode()`而不是`equals()`;这样就有可能引起意外的key冲突（背景信息可以查看[SPR-10237](https://github.com/spring-projects/spring-framework/issues/14870)）。新的`SimplekeyGenerator` 为这样场景使用了一个复合键。
>
>如果你想要继续使用早期的key策略，你可以配置过期的`org.springframework.cache.interceptor.DefaultKeyGenerator`类或者创建一个自定义基于hash的‘KeyGenerator’实现。

#### 自定义key生成声明
由于缓存是通用的，因此很可能目标方法有各种签名，而这些并不能简单的映射到缓存结构的顶部。当目标方法有多个参数且只有其中部分适合缓存（其它参数可能只是方法的逻辑）时，这一点就变成很明显。例如：
```java
@Cacheable("books")
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
```

官方文档地址：<https://docs.spring.io/spring/docs/5.0.13.RELEASE/spring-framework-reference/integration.html#cache>
