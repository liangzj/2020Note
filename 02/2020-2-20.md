# 亿级QPS下Redis常见问题与功能扩展
## 升级重启耗时长问题
### 问题描述
对于线上较大流量业务，单个Redis实例内存占用基本数G的容量，则对应的aof占比则会数十G的空间，即使每日流量低峰进行rewriteaof，减少冗余，但如果业务数据多，写操作多，aof文件仍会10G+。

此时，在Redis需要升级版本或修复bug时，如果直接重启变更，由于需要数据恢复，这个过程需要近10分钟，时间过长，会严重影响系统可用性。
### 解决方案：
对Redis扩展热升级功能，从而毫秒级操作，完全不影响业务访问，具体步骤流程如下：
+ 构建一个壳程序，保存全局的redisServer信息（包括redisDB/client等）
+ 将Redis处理逻辑封装到动态连接库So文件
+ 第一次正常启动，从磁盘加载数据
+ 后续升级，通过指令，壳程序重新加载Redis新的so文件，即可完成功能升级
+ 整个过程，所有Client连接仍然保留，升级成功后，原有Client可以继续进行读写，整个过程对业务完全透明，耗时基本毫秒级。

## 特殊场景的数据结构扩展
### 问题描述：
遇到一些特殊业务场景，是当前Redis的数据结构无法很好满足的情况。
### 解决方案：
+ 定制化扩展
    - 扩展Redis新的数据结构
    - 扩展Redis的存储模型
### 示例场景：
+ 用户关注列表
    - Redis作为缓存使用，元素(用户UID)全部是long,结构使用set。
    - miss数据重载时，如果有数万个元素，用sadd回填，数据大耗时长，而且可能导致Redis卡顿。
+ 改进方案
    - 扩展longset数据结构，一个long型一维开放数组
    - client将关注uid列表，构建成long数组的二进制数据，然后lsset回种redis
    - Redis直接存储二进制数据作为value值
    - 采用double-hash寻址及解决hash冲突
    - 填充率超过阀值，redis返回异常，有client构建更大的long型数组，一次性写入。

## 复杂计数器需求
### 问题描述
+ 一个key有多种计数列，比如 一条feed有阅读数、点赞数、评论数等
+ 海量计数，key递增，比如，每天有N个用户发布N条feed，每个又有N个维度计数
+ 一次查询，需查询大量的key，并对每个key查询多个计数

### 改进方案
+ 改造redisDB,采用cdb分段存储计数
+ 采用schema,指定计数的数量和类型，即一个keyid的多个计数用一条计数记录，计数位置使用精确到bit
+ 冷热分离，热数据存内存，冷数据存磁盘

## 主从复制模式优化-完全增量方案
### 问题描述
原生复制机制，不管sync，还是后面改进的psync及psync2,复制均受限于replbuf(复制缓存期)，如果slave断开较旧或者短期有大量数据写入（超过repl buf的量），则会触发全量复制，导致整体性能下降。

### 解决方案
 结合RDB+AOF策略，构建完全增量复制方案。
 + Aof按后缀id递增，滚动存储最新写指令
 + Rdb文件记录当前内存数据，以及构建时刻AOF文件的id及位置
 + Master通过独立的复制线程向slave同步数据
 + 第一次复制为全量复制，之后不受内存及时间限制，只要aof文件没被删除，全部为增量复制
 + 第一次复制，复制线程发送rdb给slave后，再将rdb记录的Aof文件位置之后的所有数据，也发送slave,完成全量同步
 + 后续同步，slave首先传递之前复制的Aof文件id及位置
 + Master的复制线程根据slave的aof文件位置，读取之后内容，发送个slave
 + Master同步数据时，对每个slave启用一个独立线程，复制过程不影响请求访问。 

## 集群管理优化
+ Redis剥离集群逻辑，不在维护slot相关信息
+ 构建clusterManager,负责数据的维护、迁移、状态管理
+ Redis集群访问有proxy或smart client进行
+ 配置属性从配置中心获取及协调
+ clusterManager向配置中心注册业务资源部署和状态信息
+ Proxy及Client从配置中心获取及订阅配置信息。