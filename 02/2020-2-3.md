# 缓存服务7大经典问题
## 数据不一致问题
### 问题描述：
同一份数据，同时存储DB和缓存之后或者缓存的多个副本之间，如果某个更新操作异常，就可能出现数据不一致。
### 原因分析
+ 更新DB后写缓存失败
+ 多个副本副本更新失败
+ 一致性hash分布的，如果节点多次上下线，rehash的策略处理也会有概率出现脏数据
### 业务场景
+ 方案一： cache更新失败后，可以进行重试，多次重试失败key写入队列机，待缓存恢复后，将这些key删除，让相应key，再次被请求时，重新从DB加载，从而保证一致。
+ 方案二：缓存时间适当调短，保障缓存与DB的时效差，减少差异。
+ 不用rehash漂移策略，而采用分层策略，尽量避免脏数据产生。

## 数据并发竞争
### 问题描述：
由于多个进程/线程中，有大量并发请求获取相同的数据，而这个数据正常过期、被删除等各种原因再缓存中不存在，而这些进程/线程之间没有任何协调，然后并发查询DB，请求相同key，导致DB压力大增。

### 业务场景：
在大流量系统中较常见，比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量转发、评论、赞。

### 解决方案：
+ 方案一：全局锁，缓存请求miss后，先尝试加全局锁，只有加载全局锁成功才可以到DB加载，其它进程/线程则阻塞等待加载完，再冲缓存读取。
+ 方案二：保持多个备份，即便其中一个过期，还可以访问其它备份。

## Hot Key
### 问题描述
大部分系统中数据分冷热，比如最近的新闻比久远的信封访问频率高很多，突发事件的发生，也会产生突发的被高频访问的热点数据。如果这个热点数据访问过载就容易造成服务卡顿，甚至节点宕机。
### 解决方案：
+ 找出Hot Key:  
   - 可预知的：比如重要节假日、线上促销活动、集中推送等。
   - 突发无法预知： 通过Spark，对应流任务实时分析，及时发现新发布的热点key。
   - 逐步发酵型： 之前已发生，逐步发酵成热key,则通过Hadoop对批处理任务离线计算，找出最近历史数据中高频热key。

+ 各种方案：
    - 方案一：热key分散处理  
        找出热key，加上后缀标识，分散到多个缓存节点，之后客户端请求时，随机访问某个后缀的热key,这样就将压力分散到各个节点。
    - 方案二： 提前多副本+多级结合的缓存架构设计
    - 方案三： 本地缓存，将热key记录到本地缓存，来较少对远程缓存冲击。


## Big Key
### 问题描述
缓存访问时，部分key的Value过大，读写、加载易超时的现象。

### 原因分析
大key造成慢查询的原因主要有以下几类：
+ 大key占总体数据比例较小，存Mc，对应slab较少，导致容易频繁剔除，DB反复加载，从而导致查询较慢。
+ 大key较多，同时被大量访问，导致缓存组件的网卡、带宽打满，最后导致较多大key慢查询。
+ 大key字段较多，如果个别字段变更频繁，导致key频繁更新，导致读写相互影响，最后导致慢查询。
### 业务场景：
保存用户最新1万个粉丝信息；长文微博内容。

### 解决方案：
+ 方案一： 如果存Mc中，设置一个缓存阈值，单value长度超过阈值，则启动压缩，减少size;其次评估大key占比，Mc启动之初，预写足够数据的大key,让Mc预先分配足够多的trunk size较大的slab,确保后面系统运行时，大key有足够空间进行缓存。
+ 方案二：数据存在Redis中，比如业务数据存set格式，大key对应set结构有几千几万个元素，写入redis时会消耗很长时间，导致redis卡顿，此时，可以扩展新数据结构，先系列化构建，再通过restore一次写入。

+ 方案三： 将大key拆分多个key,尽量减少大key存在。同事尽量对大key进行特殊处理，比如同等条件下设置较长的过期时间，尽量不频繁淘汰。

## 总结：
互联网系统中，实际业务错综复杂，面对高并发、海量访问、突发流量洪峰、网络或机器硬件故障，要保障服务的高性能和高可用。就务必提前构建好防御措施，避免大量key同时失效、避免不存在key大批访问穿透、减少大key/热key额缓存失效，热key分流、大key拆分或压缩。采取一系列措施，提供缓存命中率，同时保持数据的一致性。此外，提前规划缓存的SLA,实时监控QPS/响应分布、平均耗时等，方便及时跟踪应对。遇到节点异常、突发流量、极端事件，也能通过分池分层策略、key分拆等，避免故障。


# Redis基本原理
## Redis简介：
Redis(Remote dictionary server 远程字典服务)是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，可作缓存、数据库以及消息中间件，并提供多种语言的API。

## Redis特性
+ 数据结构丰富：（Mc只支持二进制字节块）
+ 高性能：单线程压测可以达到10~11w的QPS
+ 持续持久化：读写全部内存进行，单也支持所有数据持久化。
    - 快照方式： 某个时刻所有数据写入硬盘RDB文件。
    - 追加文件：将所有写命令都以追加方式写入硬盘的AOF文件。
> 线上Redis一般两种方式同时使用，通过开启appendonly相关配置项，将写命令及时追加到AOP文件，同时每日流量低峰是，通过快照保存当时所有内存数据快照。
+ 热备-主从复制：一般读操作远远大于写操作，此时可以使用Redis的复制特性，让一个Redis实例作为master，然后复制挂载多个不断同步更新的slave节点。通过读写分离，写多分配master上，读随机落在各个slave节点上，便可大幅提升整体读写能力。
+ Lua脚本：2.6版本之后开始支持，可快速自定义实现扩展。
+ 支持事务：multi指令后，指定多个操作，然后通过exec指令一次执行，中途异常则不执行，否则，按顺序执行所有操作，执行过程中不会执行任何其它指令。
+ 集群： 
    - 自动或手动将所有key按hash分散不同节点
    - 容量不足时，可通过迁移指令，把其中一部分key迁移到其它节点。


## 数据结构：

## Redis高性能

## Redis持久化

## Redis集群管理