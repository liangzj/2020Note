# 队列
## 概念
1. 操作受限的线性表数据结构，只支持入队(enqueue)和出队（dequeue）。
2. 先进先出
## 实现
需要两个指针，一个head指针指向队头，一个tail指针指向队尾。

### 顺序队列
1. 基于数组实现的队列
2. 再没有空闲空间时，在入队是再集中触发一次数据的搬移操作。
### 链式队列
1. 基于链表实现

### 循环队列
1. 用下标取余方式，使数组‘首尾’相连形成环，循环使用，规避顺序队列的空间满时的数据迁移。
2. 实现：队空和队满判定，规避头尾指针交叉越界   
    + 队列为空的判断条件是head==tail
    + 队满时，（tail+1）%n = head
3. 缺点：队满时，tail指向的结点不存储数据，会浪费一个位置。

### 阻塞队列
1. 队列基础上添加阻塞操作。
2. 队列为空时，从队头取数据会被阻塞，知道队列有数据才返回。
3. 队列已经满时，插入数据会阻塞，直到队列有空闲位置后插入数据，然后再返回

### 并发队列
1. 线程安全的队列
2. 实现机制
    + 直接enqueue()、dequeue()方法加锁，简单直接，但锁粒度大并发度低。
    + 基于数组的循环队列，利用CAS原子操作，可实现非常高效的并发队列

## 线程池没有空闲线程时，新的任务请求线程资源时，线程池如何处理？各种处理策略又是如何实现？
1. 没有空闲线程时，处理方式有两种：
    + 非阻塞处理，直接拒绝任务请求返回
    + 阻塞处理，将请求排队，等有空闲线程时，取出排队请求继续处理。
2. 阻塞处理方式：服务请求遵循先进先服务，所以采用队列来存储排队请求，排队的实现方式主要有以下两种：
    + 基于链表实现的无限排队的无界队列：该方案可能导致过多请求排队等待，响应时间过长，故不适合响应时间较敏感系统。
    + 基于数组的有界队列：队列满时接下来请求会直接拒绝，合理的队列大小很关键。太大导致等待太多，太小又体现不出队列价值，导致无法充分利用系统资源。

## 应用
1. 平时业务开发很少直接用到队列。
2. 循环队列比链式队列应用更广泛。
3. 高性能队列Djsruptor/Linux环形缓存，用到了循环并发队列。
4. java concurrent并发包利用ArrayBlockingQueue来实现公平锁。

